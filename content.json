{"meta":{"title":"Boy's Blog","subtitle":"Beginner’s Blog","description":"发现问题，解决问题","author":"zfylearn","url":"https://zfylearn.github.io","root":"/"},"pages":[{"title":"about","date":"2019-07-19T02:50:33.000Z","updated":"2019-07-19T02:52:32.576Z","comments":true,"path":"about/index.html","permalink":"https://zfylearn.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-17T14:53:39.000Z","updated":"2019-07-18T01:23:34.039Z","comments":true,"path":"categories/index.html","permalink":"https://zfylearn.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-19T08:33:55.000Z","updated":"2019-07-19T08:36:54.746Z","comments":true,"path":"friends/index.html","permalink":"https://zfylearn.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-17T15:14:02.000Z","updated":"2019-07-19T08:39:47.275Z","comments":true,"path":"tags/index.html","permalink":"https://zfylearn.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java容器、泛型及一些知识点的回顾","slug":"java容器、泛型及一些知识点的回顾","date":"2019-08-09T13:33:26.000Z","updated":"2019-08-10T05:58:25.231Z","comments":true,"path":"2019/08/09/java-rong-qi-fan-xing-ji-yi-xie-zhi-shi-dian-de-hui-gu/","link":"","permalink":"https://zfylearn.github.io/2019/08/09/java-rong-qi-fan-xing-ji-yi-xie-zhi-shi-dian-de-hui-gu/","excerpt":"","text":"记录一些自己在学习中认识不够清晰的知识点，方便自己回顾 一、 集合的知识结构图 什么时候使用集合？ 当我们需要将一些相同结构的个体整合在一起时，就可以考虑使用集合了 。举例：购物车 为什么要使用集合？ 集合和数组相似点： 都可以存储多个对象，对外作为一个整体存在，是“装其他对象的对象”. 数组：优点：线性序列效率高 缺点：长度需要初始化，且固定不变，不灵活。删除和添加效率低下；缺乏封装，操作繁琐。 因为数组的这些缺点，因此引入集合 简单概念解释 • Collection 根接口，表示一组对象 • List 有顺序可重复 ArrayList： 查询效率高，增删效率低，长度不受限实现（扩容） Linkedlist: 增删效率高，查询效率低 • Set 没有顺序不可重复 • HashSet • 采用Hashtable哈希表存储结构（神奇的结构） • 优点：添加速度快 查询速度快 删除速度快 • 缺点：无序 • LinkedHashSet • 采用哈希表存储结构，同时使用链表维护次序 • 有序（添加顺序） • TreeSet • 采用二叉树（红黑树）的存储结构 • 优点：有序 查询速度比List快（按照内容查询） • 缺点：查询速度没有HashSet快 • Map 存储一组键值对象，key和value HashMap：底层数据结构：数组加链表，键不能重复，如果重复则新的覆盖旧的 TreeMap：排序时使用 • Key 唯一 无序 • value 不唯一 无序 二、泛型（转自csdn 作者 我不是大王强） // 泛型：就是一种不确定的数据类型。 // 比如：ArrayList E就是泛型。 这种不确定的数据类型需要在使用这个类的时候才能够确定出来。 // 泛型可以省略，如果省略，默认泛型是Object类型。 // 泛型的好处： 省略了强转的代码。 可以把运行时的问题提前到编译时期。 public class Demo01Generic { public static void main(String[] args) { //创建集合不给出泛型 ArrayList list = new ArrayList(); list.add(\"hello\"); list.add(\"java\"); list.add(\"world\"); //遍历集合 for (Object obj : list) System.out.println(obj); //进行遍历，打印出每个字符串长度 for (Object obj : list) { String str = (String) obj;/*此处练习了向下转型*/ System.out.println(str.length()); } //创建集合给出泛型 ArrayList&lt;String> list2 = new ArrayList&lt;>(); //添加元素 list2.add(\"helloo\"); list2.add(\"helo\"); list2.add(\"world\"); //list2.add(100);编译的时候就会报错，如果没有给出泛型，则不会报错 //使用增强for遍历集合 for (String str2 : list2 ) { System.out.println(str2); } } } 三、构造器（一种特殊的方法） // 用于对象的初始化 // 需要注意 构造器的方法名必须和类名一致！ 构造器虽然有返回值，但是不能定义返回类型(返回值的类型肯定是本类)，不能在构造器里调用 return。 通过new关键字调用！！ 如果我们没有定义构造器，则系统会自动定义一个无参的构造方法。如果已定义则编译器不会 添加无参数构造方法！ 与普通方法一样，构造方法也可以重载 class Point{ double x,y; //构造方法名称必须和类名保持一致 public Point(double _x,double _y) { x=_x; y=_y; } public double getDistance(Point p) { return Math.sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y)); } } public class Constructor { public static void main(String[] args) { Point p=new Point(3.0,4.0); //new关键字调用 Point origin=new Point(0.0,0.0); System.out.println(p.getDistance(origin)); } } 四、Static关键字 修饰成员变量和方法，从属于类 普通变量和方法从属于对象 静态方法不能使用非静态方法 非静态方法可以使用静态 public class TestStatic { int a; static int width; //修饰成员变量，从属于类 static void gg(){ //修饰方法 //tt(); //报错静态方法不能使用非静态方法 System.out.println(\"gg\"); } void tt(){ //从属于对象 gg(); // 可以使用静态方法 System.out.println(\"tt\"); } public static void main(String[] args){ TestStatic hi = new TestStatic(); TestStatic.width = 2; // TestStatic.gg(); //gg(); // hi.gg(); //通过引用也可以访问static变量或static方法。不过，一般还 是使用类名.static成员名来访问。 // gg(); hi.tt(); //用对象引用，因为从属于对象 } } 五、this关键字 本质：创建好对象的地址 this的作用: • this表示的是当前对象本身， • 更准确地说，this代表当前对象的一个引用。 普通方法中使用this • 区分类成员属性和方法的形参. • 调用当前对象的其他方法（可以省略） • 位置：任意 构造方法中使用this • 使用this来调用其它构造方法 • 位置：必须是第一条语句 • this不能用于static方法。（底层在堆里的对象中，而静态方法在方法区） public class TeatThis { int a,b,c; TeatThis(int a,int b){ this.a=a; //区分类成员属性和方法的形参 this.b=b; } TeatThis(int a,int b,int c){ this(a,b); //调用其它构造方法 ,必须是第一条语句 this.c=c; } void sing() { } void eat() { this.sing();//调用本类中的sing()即调用当前对象的其他方法 System.out.println(\"你妈妈喊你回家吃饭\"); } public static void main(String[] args) { TeatThis hi= new TeatThis(2,3); hi.eat(); } } 再次强调 • This代表当前对象自身的引用（必须new） • This可以修饰属性，区别成员变量和局部变量 • This修饰方法 • This修饰构造方法（必须是第一条语句） 六、知识点的小问题记录 Object类是所有Java类的根基类 如果在类的声明中未使用extends关键字指明其基类，则默认基类为Object类 public class Person { ... } public class Person extends Object { ... } B b = new B(); // 则既声明了类型为B的引用，又创建了B的实例（对象），并且将b引用了B的实例（对象）。 创建对象的步骤 • 分配对象空间，并将对象的成员变量初始化为0或空 • 执行属性值的显式初始化 • 执行构造方法 • 返回对象的地址给相关变量 END","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zfylearn.github.io/tags/学习笔记/"}]},{"title":"启发性的飞机小游戏（一）","slug":"启发性的飞机小游戏（java）","date":"2019-07-22T12:16:19.000Z","updated":"2019-07-24T11:08:34.513Z","comments":true,"path":"2019/07/22/qi-fa-xing-de-fei-ji-xiao-you-xi-java/","link":"","permalink":"https://zfylearn.github.io/2019/07/22/qi-fa-xing-de-fei-ji-xiao-you-xi-java/","excerpt":"","text":"写在前面 建议先将结尾源码素材下载，供练习中的对照参考，如果遇到问题，私下补课，也可以联系博主，第一次写有点多的东西，不合理的地方可以评论留言。 游戏项目的介绍基于Eclipse的开发环境，通过AWT图形用户界面技术（现在用的少）建立java项目，目的实现：键盘操控飞机移动、炮弹任意角度飞行、碰撞爆炸效果和游戏时间计时。 一、初始化窗口 首先需要的是建立一个窗口，将背景和飞机两张图片显示出来（这里我们需要创建一个图片包和引入图片的工具类）。 代码如下： package game; import java.awt.Color; import java.awt.Frame; import java.awt.Graphics; import java.awt.Image; public class planegame extends Frame { Image planeImg =GameUtil.getImage(&quot;Image/plane.png&quot;); Image bg =GameUtil.getImage(&quot;Image/bg.jpg&quot;); @Override public void paint(Graphics g) {// 自动被调用. g相当一支画笔 g.drawImage(bg, 0,0,null); g.drawImage(planeImg,250,250,null); } /** * 初始化窗口 */ public void launchFrame() { this.setTitle(&quot;天才爱生活作品&quot;); this.setVisible(true); this.setSize(Constant.GAME_WIDTH,Constant.GAME_HEIGHT); this.setLocation(200, 200); } public static void main(String[] args) { planegame f = new planegame(); f.launchFrame(); } } 我们还需要在game包下再创建一个类，GameUtil（名字变了相应的代码则需要改变）工具类来实现图片的加载，上面 我们有引用到. 代码如下： package game; import java.awt.Image; import java.awt.image.BufferedImage; import java.io.IOException; import java.net.URL; import javax.imageio.ImageIO; public class GameUtil { // 工具类最好将构造器私有化 private GameUtil() { } /** * * 返回指定路径文件的图片对象 * @param path * @return */ public static Image getImage(String path) { BufferedImage bi = null; try { URL u = GameUtil.class.getClassLoader().getResource(path); bi = ImageIO.read(u); } catch (IOException e) { e.printStackTrace(); } return bi; } } 同2创建Constant类，方便后续的调用 public class Constant { public static final int GAME_WIDTH=500; public static final int GAME_HEIGHT=500; } 效果如下 图片素材和所有代码见文章末尾打包。 二、线程内部类实现动画 在（代码中）初始化窗口 new PaintThread().start(); //启动重画窗口的线程 创建一个内部类代码如下： //帮助我们反复的重画窗口 class PaintThread extends Thread{ @Override public void run() { while(true) { System.out.println(&quot;重画了一次&quot;);//测试使用最后删掉 repaint(); try { Thread.sleep(40); //1s=1000ms } catch (InterruptedException e) { e.printStackTrace(); } } } } 会出现窗口的闪烁问题加入双缓冲解决 private Image offScreenImage = null; public void update(Graphics g) { if(offScreenImage == null) offScreenImage = this.createImage(Constant.GAME_WIDTH,Constant.GAME_HEIGHT);//这是游戏窗口的宽度和高度 Graphics gOff = offScreenImage.getGraphics(); paint(gOff); g.drawImage(offScreenImage, 0, 0, null); } 可以将画飞机的位置定义成变量，令坐标++就会产生飞机移动的动画 三、为游戏建一个父类 类似初始化窗口 2 步骤（下面类相同方法） 代码如下： import java.awt.Graphics; import java.awt.Image; import java.awt.Rectangle; public class GameObject { Image img; double x,y; int speed; int width,height; public void drawSelf(Graphics g){ g.drawImage(img, (int)x, (int)y, null); } public GameObject(Image img, double x, double y, int speed, int width, int height) { super(); this.img = img; this.x = x; this.y = y; this.speed = speed; this.width = width; this.height = height; } public GameObject(Image img, double x, double y) { super(); this.img = img; this.x = x; this.y = y; } public GameObject() { } /** * 返回物体所在的矩形，便于后续的碰撞检测 * @return */ public Rectangle getRect() { return new Rectangle((int)x,(int)y,width,height); } } 四、飞机类 在其中封装飞机的一些方法：画自己、飞机位置方法、键盘监听、游戏存活时间. 重写一个drawself,画飞机的移动，飞机位置的方法，同时在planegame里调用Plane plane= new Plane(planeImg,250,250); 代码如下： package game; import java.awt.Graphics; import java.awt.Image; public class Plane extends GameObject { public void drawSelf(Graphics g){ g.drawImage(img, (int)x,(int) y, null); x++; } public Plane(Image img, double x, double y){ this.img = img; this.x = x; this.y = y; } } 在主窗口里写入键盘控制代码 如下 /键盘控制/ class KeyMonitor extends KeyAdapter{ @Override public void keyPressed(KeyEvent e) { plane.addDirection(e); } @Override public void keyReleased(KeyEvent e) { plane.minusDirection(e); } } 在初始化窗口增加监听 addKeyListener(new KeyMonitor()); //给窗口增加键盘的监听 在飞机类封装方法，定义变量（上、下、左、右）、增加方向的方法、x++改为根据方向判断，注释掉的存活时间部分会用到。 代码如下： import java.awt.Graphics; import java.awt.Image; import java.awt.event.KeyEvent; public class Plane extends GameObject { int speed=3; boolean left,up,right,down; /*boolean live=true;*/ public void drawSelf(Graphics g){ /*if(live) { */ g.drawImage(img, (int)x, (int)y, null); if(left) { x-=speed; } if(right) { x+=speed; } if(up) { y-=speed; } if(down) { y+=speed; } /*}else { }*/ } public Plane(Image img,double x,double y) { this.img=img; this.x=x; this.y=y; this.speed=3; this.width=40; this.height=40; } //按下某个键增加相应的方向 public void addDirection(KeyEvent e) { switch(e.getKeyCode()) { case KeyEvent.VK_LEFT: left=true; break; case KeyEvent.VK_UP: up=true; break; case KeyEvent.VK_RIGHT: right=true; break; case KeyEvent.VK_DOWN: down=true; break; } } //抬起某个键释放相应的方向 public void minusDirection(KeyEvent e) { switch(e.getKeyCode()) { case KeyEvent.VK_LEFT: left=false; break; case KeyEvent.VK_UP: up=false; break; case KeyEvent.VK_RIGHT: right=false; break; case KeyEvent.VK_DOWN: down=false; break; } } } 五、炮弹类 构造炮弹的方法 画炮弹（包括碰撞反弹） 主窗口内操作 和plane类一样主窗口new对象直接50个（可改）Shell[] shells=new Shell[50]; 初始化窗口初始化 for(int i=0;i&lt;shells.length;i++) { shells[i]= new Shell(); } 画方法里 画出所有的炮弹（位置画飞机的下面） for(int i=0;i&lt;shells.length;i++) { shells[i].draw(g); } 类代码： package game; import java.awt.Color; import java.awt.Graphics; public class Shell extends GameObject { double degree; public Shell() { x=200; y=200; width=10; height=10; speed=2; degree=Math.random()*Math.PI*2; } public void draw(Graphics g) { Color c =g.getColor(); g.setColor(Color.YELLOW); g.fillOval((int)x, (int)y, width, height);//填充 //炮弹沿着任意角度去飞 x+=speed*Math.cos(degree); y+=speed*Math.sin(degree); if(x&lt;0||x&gt;Constant.GAME_WIDTH-width) { degree =Math.PI-degree; } if(y&lt;30||y&gt;Constant.GAME_HEIGHT-height) { degree =-degree; } g.setColor(c); } } 效果： 六、碰撞检测和爆炸类 碰撞检测 主窗口画炮弹的循环里加入 boolean touch=shells[i].getRect().intersects(plane.getRect()); if(touch) { plane.live=false;} 将飞机类的注释去掉,如果发生碰撞飞机消失死掉 爆炸类 包含爆炸的位置和爆炸的图片加载 代码如下： package game; import java.awt.Graphics; import java.awt.Image; public class Explode { double x, y; static Image[] imgs = new Image[16]; static { for (int i = 0; i &lt; 16; i++) { imgs[i] = GameUtil.getImage(&quot;image/explode/e&quot; + (i + 1) + &quot;.gif&quot;); imgs[i].getWidth(null); } } int count; public void draw(Graphics g) { if (count &lt;= 15) { g.drawImage(imgs[count], (int) x, (int) y, null); count++; } } public Explode(double x, double y) { this.x = x; this.y = y; } } 在主窗口声明 Explode bao;在画炮弹方法如果飞机死亡中加入 if(bao==null) { bao= new Explode(plane.x,plane.y); } 效果 七、增加游戏计时 主窗口定义时间变量 Date startTime=new Date(); Date endTime; int period;//游戏持续的时间 在爆炸的if语句里加入 endTime=new Date();period=(int)((endTime.getTime()-startTime.getTime())/1000); 在画炮弹里加入 //计时功能，给出提示 if(!plane.live) { g.setColor(Color.red); Font f=new Font(&quot;宋体&quot;,Font.BOLD,50); g.setFont(f); g.drawString(&quot;时间：&quot;+period+&quot;秒&quot;,(int)plane.x, (int)plane.y); } 在主窗口画方法开始 加Color c=g.getColor();结束 加g.setColor(c);变回原来的颜色 源码素材","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://zfylearn.github.io/tags/java/"}]},{"title":"yilia主题配置中遇到的一些问题 ","slug":"yilia主题配置中遇到的一些问题","date":"2019-07-08T02:06:12.000Z","updated":"2019-07-24T11:08:27.702Z","comments":true,"path":"2019/07/08/yilia-zhu-ti-pei-zhi-zhong-yu-dao-de-yi-xie-wen-ti/","link":"","permalink":"https://zfylearn.github.io/2019/07/08/yilia-zhu-ti-pei-zhi-zhong-yu-dao-de-yi-xie-wen-ti/","excerpt":"","text":"一、头像设置中的问题问题 解决方法 二、推送到远端时的问题 问题如下 解决方法打开方式 打开位置 三、点击所有文章的缺失问题解决方法 1、node版本大于6.2 2、博客根目录下（和上面打开位置相同）执行命令: cnpm install hexo-generator-json-content –save（或npm） 3、在hexo的blog目录_config.yml添加配置如下，hexo g重新生成 jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 四、插件安装问题出错情况 解决方法 参考文献www.codesheep.cn https://blog.csdn.net/wsmrzx/article/details/81478945 https://blog.csdn.net/Aoman_Hao/article/details/79292862","categories":[],"tags":[{"name":"yilia主题配置中遇到的一些问题 ","slug":"yilia主题配置中遇到的一些问题","permalink":"https://zfylearn.github.io/tags/yilia主题配置中遇到的一些问题/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-14T06:55:31.480Z","updated":"2019-07-19T03:16:58.593Z","comments":true,"path":"2019/03/14/hello-world/","link":"","permalink":"https://zfylearn.github.io/2019/03/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}